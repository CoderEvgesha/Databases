# Databases

Цель данного приложения - продемонстрировать разницу между работой с СУБД H2 
посредством фреймворка Spring и работой с ООБД GemStone

# Описание логики приложения

В качестве изначальной идеи для данного приложения был взят достаточно 
игрушечный пример: предполагаем, что некая организация N в течение своего рабочего дня 
проводит какое-то количество операций. Для каждой операции есть свое обоснование, 
причина почему она была проведена. 

Общая схема работы такова: организация начинает свой рабочий день (класс Day), выполняет 
операции (класс Operation) и для каждой операции указывает список ее оснований (класс Reason).

В классе Day содержится информация о статусе и дате его смены. Существует три статуса: 
- день не открыт (0)
- день открыт (1)
- день закрыт (2)

В классе Reason содержится информация о наименовании данной причины и необязательный 
комментарий. 

В классе Operation содержится информация о наименовании данной операции, ее инициаторе и 
соответствующих основания. 

# Описание модулей приложения

В приложении представлены два модуля: spring-jpa и gemStone, каждый из которых реализует 
взаимодействие с соответствующей технологией. В обоих модулях представлена одинаковая логика.
Сборка осуществляется через Gradle.

# Сравнение Spring-Jpa и GemStone 

Все, что написано далее, является лишь моим личным мнением и не претендует на истинность.

В случае Spring-Jpa все преобразования, происходящие с объектом, осуществляются на стороне 
приложения. Несмотря на то, что в метод репозитория передается объект, очевидно, что 
происходящие "под капотом" действия вычленяют информацию об этом объекте из экземпляра класса
и сохраняют в СУБД в виде строки. Безусловно, можно зайти в саму СУБД и произвести с данной 
информацией какие-то стандартные действия, будь то удалить или обновить данные, однако это 
не равносильно отправке информации объекту. Т.е. при сохранении были потеряны свойства и 
возможность взаимодействия с сохраненной информацией именно как с объектом. Некоторая 
аналогичная картина просматривается и при извлечении данных из БД - несмотря на то, что в самом
приложении соответствующие методы также оперируют объектами, очевидно, что это уже другой объект, 
который был создан самим фреймворком на основе полученной информации. Визуально в самом приложении
присутствует ощущение, что мы оперируем только объектами за счет возможностей Spring, однако это 
не так, о чем свидетельствует невозможность оперировать информацией, сохраненной в БД, как объектом.
Также, несмотря на то, что спецификации JPA допускает наличие каких-либо методов в Entity классе,
на практике подобные классы представлены в большинстве своем только как набор полей, 
без специфичных методов. В общем и целом присутствует некоторое ощущение "процедурности" всего
происходящего.

Если говорить о GemStone, то там ситуация иная и объект по сути "размазан" между БД и самим
приложением. Об этом как минимум свидетельствует тот факт, что объект может быть сначала создан
на стороне базы, там же с ним могут быть выполнены некоторые действия как с объектом и только
потом он может быть получен на стороне приложения. Более того, не только приложение может отправлять
сообщение объекту на сервер БД, но и с сервера БД могут быть получены сообщения для объекта. 
Несомненно, что с точки зрения ООП данный подход является более предпочтительным. 

Однако при знакомстве с технологией GemStone были отмечены недостатки, которых не наблюдается
в более "стандартном" стеке:
1. Сложность в установке и подключении библиотеки (пришлось долго возится, устанавливая все ручками,
в то время как подключение Spring происходит парой строчек в файле конфигурации gradle. И да,
в самом репозитории jar тоже отсутствовал в принципе).
2. Мало обучающих материалов - по сути, единственным полноценным можно назвать только 
документацию и гайд от 2010 года. В сети в принципе содержится довольно мало информации, 
обсуждения каких-то вопросов по данной БД, что свидетельствует о небольшом комьюнити.
3. Зависимость приложения от реализации ООБД. Разумеется, тут могла сыграть роль моя неопытность 
в данной технологии, однако сложилось впечатление, что легко подменить одну ООБД на другую, 
как в случае реляционных СУБД не получится. 
4. Много кода и возможностей для выброса исключения. Вся часть, которая была связана с работой с 
базой обросла постоянными try-catch. Это не очень удобно и с точки зрения "привычного" стека 
выглядит как возвращение к JDBC. 
5. Возможность ошибки не только со стороны приложения, но и со стороны базы данных, в случае
некорректно написанного кода на Smalltalk. Иногда неочевидность происходящего, если объявлять
объекты не со стороны приложения, а со стороны БД. Возможно, это все решается каким-либо общепринятым
подходом к разработке архитектуры. 
6. Необходимость понимать SmallTalk и уметь на нем писать. В то время как со Spring-Jpa написание
запросов даже на SQL является редкостью, так как все основные запросы реализовываются в репозитариях
как java-метод. 

# Общий вывод

GemStone несомненно более предпочтителен с точки зрения ООП. Однако для промышленного приложения,
на мой взгляд, намного проще использовать Spring-Jpa. Не факт, что правильно, но быстрее и легче. 